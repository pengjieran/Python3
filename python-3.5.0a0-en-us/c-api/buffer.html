<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Buffer Protocol &mdash; Python 3.5.0a0 documentation</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.5.0a0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 3.5.0a0 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.5.0a0 documentation" href="../index.html" />
    <link rel="up" title="Abstract Objects Layer" href="abstract.html" />
    <link rel="next" title="Old Buffer Protocol" href="objbuffer.html" />
    <link rel="prev" title="Iterator Protocol" href="iter.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  </head>
  <body>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="objbuffer.html" title="Old Buffer Protocol"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="iter.html" title="Iterator Protocol"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.5.0a0</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="abstract.html" accesskey="U">Abstract Objects Layer</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="buffer-protocol">
<span id="bufferobjects"></span><span id="index-0"></span><h1>Buffer Protocol<a class="headerlink" href="#buffer-protocol" title="Permalink to this headline">¶</a></h1>
<p>Certain objects available in Python wrap access to an underlying memory
array or <em>buffer</em>.  Such objects include the built-in <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> and
<a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a>, and some extension types like <a class="reference internal" href="../library/array.html#array.array" title="array.array"><tt class="xref py py-class docutils literal"><span class="pre">array.array</span></tt></a>.
Third-party libraries may define their own types for special purposes, such
as image processing or numeric analysis.</p>
<p>While each of these types have their own semantics, they share the common
characteristic of being backed by a possibly large memory buffer.  It is
then desirable, in some situations, to access that buffer directly and
without intermediate copying.</p>
<p>Python provides such a facility at the C level in the form of the <a class="reference internal" href="#bufferobjects"><em>buffer
protocol</em></a>.  This protocol has two sides:</p>
<ul class="simple" id="index-1">
<li>on the producer side, a type can export a &#8220;buffer interface&#8221; which allows
objects of that type to expose information about their underlying buffer.
This interface is described in the section <a class="reference internal" href="typeobj.html#buffer-structs"><em>Buffer Object Structures</em></a>;</li>
<li>on the consumer side, several means are available to obtain a pointer to
the raw underlying data of an object (for example a method parameter).</li>
</ul>
<p>Simple objects such as <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> and <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> expose their
underlying buffer in byte-oriented form.  Other forms are possible; for example,
the elements exposed by a <a class="reference internal" href="../library/array.html#array.array" title="array.array"><tt class="xref py py-class docutils literal"><span class="pre">array.array</span></tt></a> can be multi-byte values.</p>
<p>An example consumer of the buffer interface is the <a class="reference internal" href="../library/io.html#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt></a>
method of file objects: any object that can export a series of bytes through
the buffer interface can be written to a file.  While <tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt> only
needs read-only access to the internal contents of the object passed to it,
other methods such as <a class="reference internal" href="../library/io.html#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><tt class="xref py py-meth docutils literal"><span class="pre">readinto()</span></tt></a> need write access
to the contents of their argument.  The buffer interface allows objects to
selectively allow or reject exporting of read-write and read-only buffers.</p>
<p>There are two ways for a consumer of the buffer interface to acquire a buffer
over a target object:</p>
<ul class="simple">
<li>call <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></tt></a> with the right parameters;</li>
<li>call <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a> (or one of its siblings) with one of the
<tt class="docutils literal"><span class="pre">y*</span></tt>, <tt class="docutils literal"><span class="pre">w*</span></tt> or <tt class="docutils literal"><span class="pre">s*</span></tt> <a class="reference internal" href="arg.html#arg-parsing"><em>format codes</em></a>.</li>
</ul>
<p>In both cases, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></tt></a> must be called when the buffer
isn&#8217;t needed anymore.  Failure to do so could lead to various issues such as
resource leaks.</p>
<div class="section" id="buffer-structure">
<span id="id1"></span><h2>Buffer structure<a class="headerlink" href="#buffer-structure" title="Permalink to this headline">¶</a></h2>
<p>Buffer structures (or simply &#8220;buffers&#8221;) are useful as a way to expose the
binary data from another object to the Python programmer.  They can also be
used as a zero-copy slicing mechanism.  Using their ability to reference a
block of memory, it is possible to expose any data to the Python programmer
quite easily.  The memory could be a large, constant array in a C extension,
it could be a raw block of memory for manipulation before passing to an
operating system library, or it could be used to pass around structured data
in its native, in-memory format.</p>
<p>Contrary to most data types exposed by the Python interpreter, buffers
are not <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject</span></tt></a> pointers but rather simple C structures.  This
allows them to be created and copied very simply.  When a generic wrapper
around a buffer is needed, a <a class="reference internal" href="memoryview.html#memoryview-objects"><em>memoryview</em></a> object
can be created.</p>
<p>For short instructions how to write an exporting object, see
<a class="reference internal" href="typeobj.html#buffer-structs"><em>Buffer Object Structures</em></a>. For obtaining
a buffer, see <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></tt></a>.</p>
<dl class="type">
<dt id="c.Py_buffer">
<tt class="descname">Py_buffer</tt><a class="headerlink" href="#c.Py_buffer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="member">
<dt id="c.Py_buffer.buf">
void *<tt class="descname">buf</tt><a class="headerlink" href="#c.Py_buffer.buf" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the start of the logical structure described by the buffer
fields. This can be any location within the underlying physical memory
block of the exporter. For example, with negative <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><tt class="xref c c-member docutils literal"><span class="pre">strides</span></tt></a>
the value may point to the end of the memory block.</p>
<p>For contiguous arrays, the value points to the beginning of the memory
block.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.obj">
void *<tt class="descname">obj</tt><a class="headerlink" href="#c.Py_buffer.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>A new reference to the exporting object. The reference is owned by
the consumer and automatically decremented and set to <em>NULL</em> by
<a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></tt></a>. The field is the equivalent of the return
value of any standard C-API function.</p>
<p>As a special case, for <em>temporary</em> buffers that are wrapped by
<a class="reference internal" href="memoryview.html#c.PyMemoryView_FromBuffer" title="PyMemoryView_FromBuffer"><tt class="xref c c-func docutils literal"><span class="pre">PyMemoryView_FromBuffer()</span></tt></a> or <a class="reference internal" href="#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_FillInfo()</span></tt></a>
this field is <em>NULL</em>. In general, exporting objects MUST NOT
use this scheme.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.len">
Py_ssize_t <tt class="descname">len</tt><a class="headerlink" href="#c.Py_buffer.len" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span></tt>. For contiguous arrays, this is the length
of the underlying memory block. For non-contiguous arrays, it is the length
that the logical structure would have if it were copied to a contiguous
representation.</p>
<p>Accessing <tt class="docutils literal"><span class="pre">((char</span> <span class="pre">*)buf)[0]</span> <span class="pre">up</span> <span class="pre">to</span> <span class="pre">((char</span> <span class="pre">*)buf)[len-1]</span></tt> is only valid
if the buffer has been obtained by a request that guarantees contiguity. In
most cases such a request will be <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_SIMPLE</span></tt></a> or <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_WRITABLE</span></tt></a>.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.readonly">
int <tt class="descname">readonly</tt><a class="headerlink" href="#c.Py_buffer.readonly" title="Permalink to this definition">¶</a></dt>
<dd><p>An indicator of whether the buffer is read-only. This field is controlled
by the <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_WRITABLE</span></tt></a> flag.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.itemsize">
Py_ssize_t <tt class="descname">itemsize</tt><a class="headerlink" href="#c.Py_buffer.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Item size in bytes of a single element. Same as the value of <a class="reference internal" href="../library/struct.html#struct.calcsize" title="struct.calcsize"><tt class="xref py py-func docutils literal"><span class="pre">struct.calcsize()</span></tt></a>
called on non-NULL <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><tt class="xref c c-member docutils literal"><span class="pre">format</span></tt></a> values.</p>
<p>Important exception: If a consumer requests a buffer without the
<a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_FORMAT</span></tt></a> flag, <tt class="xref c c-member docutils literal"><span class="pre">format</span></tt> will
be set to  <em>NULL</em>,  but <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><tt class="xref c c-member docutils literal"><span class="pre">itemsize</span></tt></a> still has
the value for the original format.</p>
<p>If <tt class="xref c c-member docutils literal"><span class="pre">shape</span></tt> is present, the equality
<tt class="docutils literal"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len</span></tt> still holds and the consumer
can use <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><tt class="xref c c-member docutils literal"><span class="pre">itemsize</span></tt></a> to navigate the buffer.</p>
<p>If <tt class="xref c c-member docutils literal"><span class="pre">shape</span></tt> is <em>NULL</em> as a result of a <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_SIMPLE</span></tt></a>
or a <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_WRITABLE</span></tt></a> request, the consumer must disregard
<a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><tt class="xref c c-member docutils literal"><span class="pre">itemsize</span></tt></a> and assume <tt class="docutils literal"><span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">1</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.format">
const char *<tt class="descname">format</tt><a class="headerlink" href="#c.Py_buffer.format" title="Permalink to this definition">¶</a></dt>
<dd><p>A <em>NUL</em> terminated string in <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><tt class="xref py py-mod docutils literal"><span class="pre">struct</span></tt></a> module style syntax describing
the contents of a single item. If this is <em>NULL</em>, <tt class="docutils literal"><span class="pre">&quot;B&quot;</span></tt> (unsigned bytes)
is assumed.</p>
<p>This field is controlled by the <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_FORMAT</span></tt></a> flag.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.ndim">
int <tt class="descname">ndim</tt><a class="headerlink" href="#c.Py_buffer.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dimensions the memory represents as an n-dimensional array.
If it is 0, <tt class="xref c c-member docutils literal"><span class="pre">buf</span></tt> points to a single item representing
a scalar. In this case, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><tt class="xref c c-member docutils literal"><span class="pre">shape</span></tt></a>, <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><tt class="xref c c-member docutils literal"><span class="pre">strides</span></tt></a>
and <a class="reference internal" href="#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><tt class="xref c c-member docutils literal"><span class="pre">suboffsets</span></tt></a> MUST be <em>NULL</em>.</p>
<p>The macro <tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_MAX_NDIM</span></tt> limits the maximum number of dimensions
to 64. Exporters MUST respect this limit, consumers of multi-dimensional
buffers SHOULD be able to handle up to <tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_MAX_NDIM</span></tt> dimensions.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.shape">
Py_ssize_t *<tt class="descname">shape</tt><a class="headerlink" href="#c.Py_buffer.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt> of length <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><tt class="xref c c-member docutils literal"><span class="pre">ndim</span></tt></a>
indicating the shape of the memory as an n-dimensional array. Note that
<tt class="docutils literal"><span class="pre">shape[0]</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">shape[ndim-1]</span> <span class="pre">*</span> <span class="pre">itemsize</span></tt> MUST be equal to
<a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><tt class="xref c c-member docutils literal"><span class="pre">len</span></tt></a>.</p>
<p>Shape values are restricted to <tt class="docutils literal"><span class="pre">shape[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>. The case
<tt class="docutils literal"><span class="pre">shape[n]</span> <span class="pre">==</span> <span class="pre">0</span></tt> requires special attention. See <a class="reference internal" href="#complex-arrays">complex arrays</a>
for further information.</p>
<p>The shape array is read-only for the consumer.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.strides">
Py_ssize_t *<tt class="descname">strides</tt><a class="headerlink" href="#c.Py_buffer.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt> of length <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><tt class="xref c c-member docutils literal"><span class="pre">ndim</span></tt></a>
giving the number of bytes to skip to get to a new element in each
dimension.</p>
<p>Stride values can be any integer. For regular arrays, strides are
usually positive, but a consumer MUST be able to handle the case
<tt class="docutils literal"><span class="pre">strides[n]</span> <span class="pre">&lt;=</span> <span class="pre">0</span></tt>. See <a class="reference internal" href="#complex-arrays">complex arrays</a> for further information.</p>
<p>The strides array is read-only for the consumer.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.suboffsets">
Py_ssize_t *<tt class="descname">suboffsets</tt><a class="headerlink" href="#c.Py_buffer.suboffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt> of length <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><tt class="xref c c-member docutils literal"><span class="pre">ndim</span></tt></a>.
If <tt class="docutils literal"><span class="pre">suboffsets[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>, the values stored along the nth dimension are
pointers and the suboffset value dictates how many bytes to add to each
pointer after de-referencing. A suboffset value that is negative
indicates that no de-referencing should occur (striding in a contiguous
memory block).</p>
<p>This type of array representation is used by the Python Imaging Library
(PIL). See <a class="reference internal" href="#complex-arrays">complex arrays</a> for further information how to access elements
of such an array.</p>
<p>The suboffsets array is read-only for the consumer.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.internal">
void *<tt class="descname">internal</tt><a class="headerlink" href="#c.Py_buffer.internal" title="Permalink to this definition">¶</a></dt>
<dd><p>This is for use internally by the exporting object. For example, this
might be re-cast as an integer by the exporter and used to store flags
about whether or not the shape, strides, and suboffsets arrays must be
freed when the buffer is released. The consumer MUST NOT alter this
value.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="buffer-request-types">
<span id="id2"></span><h2>Buffer request types<a class="headerlink" href="#buffer-request-types" title="Permalink to this headline">¶</a></h2>
<p>Buffers are usually obtained by sending a buffer request to an exporting
object via <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></tt></a>. Since the complexity of the logical
structure of the memory can vary drastically, the consumer uses the <em>flags</em>
argument to specify the exact buffer type it can handle.</p>
<p>All <a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><tt class="xref c c-data docutils literal"><span class="pre">Py_buffer</span></tt></a> fields are unambiguously defined by the request
type.</p>
<div class="section" id="request-independent-fields">
<h3>request-independent fields<a class="headerlink" href="#request-independent-fields" title="Permalink to this headline">¶</a></h3>
<p>The following fields are not influenced by <em>flags</em> and must always be filled in
with the correct values: <a class="reference internal" href="#c.Py_buffer.obj" title="Py_buffer.obj"><tt class="xref c c-member docutils literal"><span class="pre">obj</span></tt></a>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><tt class="xref c c-member docutils literal"><span class="pre">buf</span></tt></a>,
<a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><tt class="xref c c-member docutils literal"><span class="pre">len</span></tt></a>, <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><tt class="xref c c-member docutils literal"><span class="pre">itemsize</span></tt></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><tt class="xref c c-member docutils literal"><span class="pre">ndim</span></tt></a>.</p>
</div>
<div class="section" id="readonly-format">
<h3>readonly, format<a class="headerlink" href="#readonly-format" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><dl class="macro">
<dt id="c.PyBUF_WRITABLE">
<tt class="descname">PyBUF_WRITABLE</tt><a class="headerlink" href="#c.PyBUF_WRITABLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the <a class="reference internal" href="#c.Py_buffer.readonly" title="Py_buffer.readonly"><tt class="xref c c-member docutils literal"><span class="pre">readonly</span></tt></a> field. If set, the exporter
MUST provide a writable buffer or else report failure. Otherwise, the
exporter MAY provide either a read-only or writable buffer, but the choice
MUST be consistent for all consumers.</p>
</dd></dl>

<dl class="macro">
<dt id="c.PyBUF_FORMAT">
<tt class="descname">PyBUF_FORMAT</tt><a class="headerlink" href="#c.PyBUF_FORMAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><tt class="xref c c-member docutils literal"><span class="pre">format</span></tt></a> field. If set, this field MUST
be filled in correctly. Otherwise, this field MUST be <em>NULL</em>.</p>
</dd></dl>

</div></blockquote>
<p><a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_WRITABLE</span></tt></a> can be |&#8217;d to any of the flags in the next section.
Since <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_SIMPLE</span></tt></a> is defined as 0, <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_WRITABLE</span></tt></a>
can be used as a stand-alone flag to request a simple writable buffer.</p>
<p><a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_FORMAT</span></tt></a> can be |&#8217;d to any of the flags except <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_SIMPLE</span></tt></a>.
The latter already implies format <tt class="docutils literal"><span class="pre">B</span></tt> (unsigned bytes).</p>
</div>
<div class="section" id="shape-strides-suboffsets">
<h3>shape, strides, suboffsets<a class="headerlink" href="#shape-strides-suboffsets" title="Permalink to this headline">¶</a></h3>
<p>The flags that control the logical structure of the memory are listed
in decreasing order of complexity. Note that each flag contains all bits
of the flags below it.</p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="12%" />
<col width="16%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Request</th>
<th class="head">shape</th>
<th class="head">strides</th>
<th class="head">suboffsets</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_INDIRECT">
<tt class="descname">PyBUF_INDIRECT</tt><a class="headerlink" href="#c.PyBUF_INDIRECT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>if needed</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt id="c.PyBUF_STRIDES">
<tt class="descname">PyBUF_STRIDES</tt><a class="headerlink" href="#c.PyBUF_STRIDES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
</tr>
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_ND">
<tt class="descname">PyBUF_ND</tt><a class="headerlink" href="#c.PyBUF_ND" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt id="c.PyBUF_SIMPLE">
<tt class="descname">PyBUF_SIMPLE</tt><a class="headerlink" href="#c.PyBUF_SIMPLE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="contiguity-requests">
<h3>contiguity requests<a class="headerlink" href="#contiguity-requests" title="Permalink to this headline">¶</a></h3>
<p>C or Fortran contiguity can be explicitly requested, with and without stride
information. Without stride information, the buffer must be C-contiguous.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="10%" />
<col width="13%" />
<col width="17%" />
<col width="11%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Request</th>
<th class="head">shape</th>
<th class="head">strides</th>
<th class="head">suboffsets</th>
<th class="head">contig</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_C_CONTIGUOUS">
<tt class="descname">PyBUF_C_CONTIGUOUS</tt><a class="headerlink" href="#c.PyBUF_C_CONTIGUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
<td>C</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt id="c.PyBUF_F_CONTIGUOUS">
<tt class="descname">PyBUF_F_CONTIGUOUS</tt><a class="headerlink" href="#c.PyBUF_F_CONTIGUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
<td>F</td>
</tr>
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_ANY_CONTIGUOUS">
<tt class="descname">PyBUF_ANY_CONTIGUOUS</tt><a class="headerlink" href="#c.PyBUF_ANY_CONTIGUOUS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
<td>C or F</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt>
<tt class="descname">PyBUF_ND</tt></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>NULL</td>
<td>NULL</td>
<td>C</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compound-requests">
<h3>compound requests<a class="headerlink" href="#compound-requests" title="Permalink to this headline">¶</a></h3>
<p>All possible requests are fully defined by some combination of the flags in
the previous section. For convenience, the buffer protocol provides frequently
used combinations as single flags.</p>
<p>In the following table <em>U</em> stands for undefined contiguity. The consumer would
have to call <a class="reference internal" href="#c.PyBuffer_IsContiguous" title="PyBuffer_IsContiguous"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_IsContiguous()</span></tt></a> to determine contiguity.</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="8%" />
<col width="11%" />
<col width="14%" />
<col width="9%" />
<col width="12%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Request</th>
<th class="head">shape</th>
<th class="head">strides</th>
<th class="head">suboffsets</th>
<th class="head">contig</th>
<th class="head">readonly</th>
<th class="head">format</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_FULL">
<tt class="descname">PyBUF_FULL</tt><a class="headerlink" href="#c.PyBUF_FULL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>if needed</td>
<td>U</td>
<td>0</td>
<td>yes</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt id="c.PyBUF_FULL_RO">
<tt class="descname">PyBUF_FULL_RO</tt><a class="headerlink" href="#c.PyBUF_FULL_RO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>if needed</td>
<td>U</td>
<td>1 or 0</td>
<td>yes</td>
</tr>
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_RECORDS">
<tt class="descname">PyBUF_RECORDS</tt><a class="headerlink" href="#c.PyBUF_RECORDS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
<td>U</td>
<td>0</td>
<td>yes</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt id="c.PyBUF_RECORDS_RO">
<tt class="descname">PyBUF_RECORDS_RO</tt><a class="headerlink" href="#c.PyBUF_RECORDS_RO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
<td>U</td>
<td>1 or 0</td>
<td>yes</td>
</tr>
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_STRIDED">
<tt class="descname">PyBUF_STRIDED</tt><a class="headerlink" href="#c.PyBUF_STRIDED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
<td>U</td>
<td>0</td>
<td>NULL</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt id="c.PyBUF_STRIDED_RO">
<tt class="descname">PyBUF_STRIDED_RO</tt><a class="headerlink" href="#c.PyBUF_STRIDED_RO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>yes</td>
<td>NULL</td>
<td>U</td>
<td>1 or 0</td>
<td>NULL</td>
</tr>
<tr class="row-even"><td><dl class="first last macro">
<dt id="c.PyBUF_CONTIG">
<tt class="descname">PyBUF_CONTIG</tt><a class="headerlink" href="#c.PyBUF_CONTIG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>NULL</td>
<td>NULL</td>
<td>C</td>
<td>0</td>
<td>NULL</td>
</tr>
<tr class="row-odd"><td><dl class="first last macro">
<dt id="c.PyBUF_CONTIG_RO">
<tt class="descname">PyBUF_CONTIG_RO</tt><a class="headerlink" href="#c.PyBUF_CONTIG_RO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td>yes</td>
<td>NULL</td>
<td>NULL</td>
<td>C</td>
<td>1 or 0</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="complex-arrays">
<h2>Complex arrays<a class="headerlink" href="#complex-arrays" title="Permalink to this headline">¶</a></h2>
<div class="section" id="numpy-style-shape-and-strides">
<h3>NumPy-style: shape and strides<a class="headerlink" href="#numpy-style-shape-and-strides" title="Permalink to this headline">¶</a></h3>
<p>The logical structure of NumPy-style arrays is defined by <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><tt class="xref c c-member docutils literal"><span class="pre">itemsize</span></tt></a>,
<a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><tt class="xref c c-member docutils literal"><span class="pre">ndim</span></tt></a>, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><tt class="xref c c-member docutils literal"><span class="pre">shape</span></tt></a> and <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><tt class="xref c c-member docutils literal"><span class="pre">strides</span></tt></a>.</p>
<p>If <tt class="docutils literal"><span class="pre">ndim</span> <span class="pre">==</span> <span class="pre">0</span></tt>, the memory location pointed to by <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><tt class="xref c c-member docutils literal"><span class="pre">buf</span></tt></a> is
interpreted as a scalar of size <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><tt class="xref c c-member docutils literal"><span class="pre">itemsize</span></tt></a>. In that case,
both <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><tt class="xref c c-member docutils literal"><span class="pre">shape</span></tt></a> and <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><tt class="xref c c-member docutils literal"><span class="pre">strides</span></tt></a> are <em>NULL</em>.</p>
<p>If <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><tt class="xref c c-member docutils literal"><span class="pre">strides</span></tt></a> is <em>NULL</em>, the array is interpreted as
a standard n-dimensional C-array. Otherwise, the consumer must access an
n-dimensional array as follows:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">ptr</span> <span class="pre">=</span> <span class="pre">(char</span> <span class="pre">*)buf</span> <span class="pre">+</span> <span class="pre">indices[0]</span> <span class="pre">*</span> <span class="pre">strides[0]</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">indices[n-1]</span> <span class="pre">*</span> <span class="pre">strides[n-1]</span></tt>
<tt class="docutils literal"><span class="pre">item</span> <span class="pre">=</span> <span class="pre">*((typeof(item)</span> <span class="pre">*)ptr);</span></tt></div></blockquote>
<p>As noted above, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><tt class="xref c c-member docutils literal"><span class="pre">buf</span></tt></a> can point to any location within
the actual memory block. An exporter can check the validity of a buffer with
this function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_structure</span><span class="p">(</span><span class="n">memlen</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Verify that the parameters represent a valid array within</span>
<span class="sd">       the bounds of the allocated memory:</span>
<span class="sd">           char *mem: start of the physical memory block</span>
<span class="sd">           memlen: length of the physical memory block</span>
<span class="sd">           offset: (char *)buf - mem</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">%</span> <span class="n">itemsize</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">offset</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="n">memlen</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="n">itemsize</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strides</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">strides</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">imin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">imax</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="o">+</span><span class="n">imin</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">+</span><span class="n">imax</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&lt;=</span> <span class="n">memlen</span>
</pre></div>
</div>
</div>
<div class="section" id="pil-style-shape-strides-and-suboffsets">
<h3>PIL-style: shape, strides and suboffsets<a class="headerlink" href="#pil-style-shape-strides-and-suboffsets" title="Permalink to this headline">¶</a></h3>
<p>In addition to the regular items, PIL-style arrays can contain pointers
that must be followed in order to get to the next element in a dimension.
For example, the regular three-dimensional C-array <tt class="docutils literal"><span class="pre">char</span> <span class="pre">v[2][2][3]</span></tt> can
also be viewed as an array of 2 pointers to 2 two-dimensional arrays:
<tt class="docutils literal"><span class="pre">char</span> <span class="pre">(*v[2])[2][3]</span></tt>. In suboffsets representation, those two pointers
can be embedded at the start of <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><tt class="xref c c-member docutils literal"><span class="pre">buf</span></tt></a>, pointing
to two <tt class="docutils literal"><span class="pre">char</span> <span class="pre">x[2][3]</span></tt> arrays that can be located anywhere in memory.</p>
<p>Here is a function that returns a pointer to the element in an N-D array
pointed to by an N-dimensional index when there are both non-NULL strides
and suboffsets:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">get_item_pointer</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndim</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">strides</span><span class="p">,</span>
                       <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">suboffsets</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pointer</span> <span class="o">+=</span> <span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="buffer-related-functions">
<h2>Buffer-related functions<a class="headerlink" href="#buffer-related-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.PyObject_CheckBuffer">
int <tt class="descname">PyObject_CheckBuffer</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*obj</em><big>)</big><a class="headerlink" href="#c.PyObject_CheckBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 if <em>obj</em> supports the buffer interface otherwise 0.  When 1 is
returned, it doesn&#8217;t guarantee that <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></tt></a> will
succeed.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GetBuffer">
int <tt class="descname">PyObject_GetBuffer</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*exporter</em>, <a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em>&nbsp;*view</em>, int<em>&nbsp;flags</em><big>)</big><a class="headerlink" href="#c.PyObject_GetBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a request to <em>exporter</em> to fill in <em>view</em> as specified by  <em>flags</em>.
If the exporter cannot provide a buffer of the exact type, it MUST raise
<tt class="xref c c-data docutils literal"><span class="pre">PyExc_BufferError</span></tt>, set <tt class="xref c c-member docutils literal"><span class="pre">view-&gt;obj</span></tt> to <em>NULL</em> and
return -1.</p>
<p>On success, fill in <em>view</em>, set <tt class="xref c c-member docutils literal"><span class="pre">view-&gt;obj</span></tt> to a new reference
to <em>exporter</em> and return 0. In the case of chained buffer providers
that redirect requests to a single object, <tt class="xref c c-member docutils literal"><span class="pre">view-&gt;obj</span></tt> MAY
refer to this object instead of <em>exporter</em> (See <a class="reference internal" href="typeobj.html#buffer-structs"><em>Buffer Object Structures</em></a>).</p>
<p>Successful calls to <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></tt></a> must be paired with calls
to <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></tt></a>, similar to <tt class="xref c c-func docutils literal"><span class="pre">malloc()</span></tt> and <tt class="xref c c-func docutils literal"><span class="pre">free()</span></tt>.
Thus, after the consumer is done with the buffer, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></tt></a>
must be called exactly once.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_Release">
void <tt class="descname">PyBuffer_Release</tt><big>(</big><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em>&nbsp;*view</em><big>)</big><a class="headerlink" href="#c.PyBuffer_Release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the buffer <em>view</em> and decrement the reference count for
<tt class="xref c c-member docutils literal"><span class="pre">view-&gt;obj</span></tt>. This function MUST be called when the buffer
is no longer being used, otherwise reference leaks may occur.</p>
<p>It is an error to call this function on a buffer that was not obtained via
<a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><tt class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_SizeFromFormat">
Py_ssize_t <tt class="descname">PyBuffer_SizeFromFormat</tt><big>(</big>const char<em>&nbsp;*</em><big>)</big><a class="headerlink" href="#c.PyBuffer_SizeFromFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the implied <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><tt class="xref c c-data docutils literal"><span class="pre">itemsize</span></tt></a> from <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><tt class="xref c c-data docutils literal"><span class="pre">format</span></tt></a>.
This function is not yet implemented.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_IsContiguous">
int <tt class="descname">PyBuffer_IsContiguous</tt><big>(</big><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em>&nbsp;*view</em>, char<em>&nbsp;order</em><big>)</big><a class="headerlink" href="#c.PyBuffer_IsContiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 1 if the memory defined by the <em>view</em> is C-style (<em>order</em> is
<tt class="docutils literal"><span class="pre">'C'</span></tt>) or Fortran-style (<em>order</em> is <tt class="docutils literal"><span class="pre">'F'</span></tt>) contiguous or either one
(<em>order</em> is <tt class="docutils literal"><span class="pre">'A'</span></tt>).  Return 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_FillContiguousStrides">
void <tt class="descname">PyBuffer_FillContiguousStrides</tt><big>(</big>int<em>&nbsp;ndim</em>, Py_ssize_t<em>&nbsp;*shape</em>, Py_ssize_t<em>&nbsp;*strides</em>, Py_ssize_t<em>&nbsp;itemsize</em>, char<em>&nbsp;order</em><big>)</big><a class="headerlink" href="#c.PyBuffer_FillContiguousStrides" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the <em>strides</em> array with byte-strides of a contiguous (C-style if
<em>order</em> is <tt class="docutils literal"><span class="pre">'C'</span></tt> or Fortran-style if <em>order</em> is <tt class="docutils literal"><span class="pre">'F'</span></tt>) array of the
given shape with the given number of bytes per element.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_FillInfo">
int <tt class="descname">PyBuffer_FillInfo</tt><big>(</big><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em>&nbsp;*view</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*exporter</em>, void<em>&nbsp;*buf</em>, Py_ssize_t<em>&nbsp;len</em>, int<em>&nbsp;readonly</em>, int<em>&nbsp;flags</em><big>)</big><a class="headerlink" href="#c.PyBuffer_FillInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle buffer requests for an exporter that wants to expose <em>buf</em> of size <em>len</em>
with writability set according to <em>readonly</em>. <em>buf</em> is interpreted as a sequence
of unsigned bytes.</p>
<p>The <em>flags</em> argument indicates the request type. This function always fills in
<em>view</em> as specified by flags, unless <em>buf</em> has been designated as read-only
and <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><tt class="xref c c-macro docutils literal"><span class="pre">PyBUF_WRITABLE</span></tt></a> is set in <em>flags</em>.</p>
<p>On success, set <tt class="xref c c-member docutils literal"><span class="pre">view-&gt;obj</span></tt> to a new reference to <em>exporter</em> and
return 0. Otherwise, raise <tt class="xref c c-data docutils literal"><span class="pre">PyExc_BufferError</span></tt>, set
<tt class="xref c c-member docutils literal"><span class="pre">view-&gt;obj</span></tt> to <em>NULL</em> and return -1;</p>
<p>If this function is used as part of a <a class="reference internal" href="typeobj.html#buffer-structs"><em>getbufferproc</em></a>,
<em>exporter</em> MUST be set to the exporting object and <em>flags</em> must be passed
unmodified. Otherwise, <em>exporter</em> MUST be NULL.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Buffer Protocol</a><ul>
<li><a class="reference internal" href="#buffer-structure">Buffer structure</a></li>
<li><a class="reference internal" href="#buffer-request-types">Buffer request types</a><ul>
<li><a class="reference internal" href="#request-independent-fields">request-independent fields</a></li>
<li><a class="reference internal" href="#readonly-format">readonly, format</a></li>
<li><a class="reference internal" href="#shape-strides-suboffsets">shape, strides, suboffsets</a></li>
<li><a class="reference internal" href="#contiguity-requests">contiguity requests</a></li>
<li><a class="reference internal" href="#compound-requests">compound requests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-arrays">Complex arrays</a><ul>
<li><a class="reference internal" href="#numpy-style-shape-and-strides">NumPy-style: shape and strides</a></li>
<li><a class="reference internal" href="#pil-style-shape-strides-and-suboffsets">PIL-style: shape, strides and suboffsets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-related-functions">Buffer-related functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="iter.html"
                        title="previous chapter">Iterator Protocol</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="objbuffer.html"
                        title="next chapter">Old Buffer Protocol</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/c-api/buffer.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="objbuffer.html" title="Old Buffer Protocol"
             >next</a> |</li>
        <li class="right" >
          <a href="iter.html" title="Iterator Protocol"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.5.0a0</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="abstract.html" >Abstract Objects Layer</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2014, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Jun 30, 2014.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.
    </div>

  </body>
</html>